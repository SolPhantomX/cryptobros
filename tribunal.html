<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CRYPTOBROS TRIBUNAL - AI Multi-Agent Risk Assessment</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&family=Inter:wght@300;400;500;600;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"></noscript>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Inter', sans-serif;
  background: #00052a;
  color: #00ff9d;
  min-height: 100vh;
  overflow-x: hidden;
  position: relative;
}
body::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background:
    radial-gradient(circle at 15% 25%, rgba(0, 255, 157, 0.08), transparent 40%),
    radial-gradient(circle at 85% 75%, rgba(102, 255, 255, 0.08), transparent 40%),
    radial-gradient(circle at 50% 50%, rgba(215, 0, 255, 0.05), transparent 50%),
    linear-gradient(45deg,
      transparent 24%,
      rgba(0, 255, 157, 0.07) 25%,
      rgba(0, 255, 157, 0.07) 26%,
      transparent 27%,
      transparent 74%,
      rgba(102, 255, 255, 0.07) 75%,
      rgba(102, 255, 255, 0.07) 76%,
      transparent 77%
    ),
    linear-gradient(135deg,
      transparent 24%,
      rgba(0, 255, 157, 0.07) 25%,
      rgba(0, 255, 157, 0.07) 26%,
      transparent 27%,
      transparent 74%,
      rgba(102, 255, 255, 0.07) 75%,
      rgba(102, 255, 255, 0.07) 76%,
      transparent 77%
    );
  background-size: 100px 100px;
  z-index: -1;
  pointer-events: none;
}
.neon-network {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: -1;
  opacity: 0.9;
}
.neon-node {
  position: absolute;
  width: 4px; height: 4px;
  border-radius: 50%;
  box-shadow: 0 0 6px currentColor;
}
.neon-node:nth-child(1) { top: 18%; left: 22%; background: #00ff9d; color: #00ff9d; }
.neon-node:nth-child(2) { top: 68%; left: 18%; background: #00ff9d; color: #00ff9d; }
.neon-node:nth-child(3) { top: 32%; left: 82%; background: #66ffff; color: #66ffff; }
.neon-node:nth-child(4) { top: 82%; left: 58%; background: #00ff9d; color: #00ff9d; }
.neon-node:nth-child(5) { top: 52%; left: 42%; background: #d700ff; color: #d700ff; }
.neon-node:nth-child(6) { top: 45%; left: 75%; background: #66ffff; color: #66ffff; }
.neon-node:nth-child(7) { top: 25%; left: 65%; background: #00ff9d; color: #00ff9d; }
.neon-node:nth-child(8) { top: 72%; left: 38%; background: #d700ff; color: #d700ff; }
.neon-connection {
  position: absolute;
  height: 1px;
  background: linear-gradient(to right, transparent, #00ff9d, transparent);
  opacity: 0.6;
}
.neon-connection:nth-child(1) { top: 20%; left: 22%; width: 120px; transform: rotate(30deg); }
.neon-connection:nth-child(2) { top: 35%; left: 25%; width: 180px; transform: rotate(45deg); }
.neon-connection:nth-child(3) { top: 65%; left: 20%; width: 150px; transform: rotate(15deg); }
.neon-connection:nth-child(4) { top: 40%; left: 65%; width: 200px; transform: rotate(-25deg); }
.neon-connection:nth-child(5) { top: 75%; left: 40%; width: 130px; transform: rotate(-40deg); }
.neon-connection:nth-child(6) { top: 55%; left: 42%; width: 160px; transform: rotate(60deg); }
.neon-connection:nth-child(7) { top: 30%; left: 70%; width: 140px; transform: rotate(-15deg); }
@keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
.neon-node, .neon-connection { animation: pulse 3.5s infinite; }
.container { max-width: 1200px; margin: 0 auto; padding: 20px; position: relative; z-index: 1; }
header { text-align: center; padding: 30px 0; }
h1 {
  font-family: 'Poppins', sans-serif;
  font-size: 3em;
  font-weight: 800;
  text-shadow: 0 0 10px #00ff9d, 0 0 20px #00ff9d;
  margin-bottom: 10px;
  letter-spacing: -0.5px;
}
.subtitle {
  font-family: 'Poppins', sans-serif;
  font-size: 1.2em;
  color: #66ffff;
  margin-top: 10px;
  font-weight: 600;
}
.lang-switch {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(0, 5, 42, 0.85);
  border: 1px solid #00ff9d;
  color: #00ff9d;
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s;
  font-family: 'Inter', sans-serif;
  font-size: 0.9em;
}
.lang-switch:hover {
  background: rgba(0, 255, 157, 0.1);
  box-shadow: 0 0 15px #00ff9d;
}
.input-section {
  background: rgba(0, 5, 42, 0.85);
  border: 2px solid #00ff9d;
  border-radius: 15px;
  padding: 30px;
  margin: 30px 0;
}
.input-group {
  display: flex;
  gap: 15px;
  margin-bottom: 20px;
}
input[type="text"] {
  flex: 1;
  padding: 15px;
  background: rgba(0, 5, 42, 0.9);
  border: 2px solid #00ff9d;
  border-radius: 10px;
  color: #00ff9d;
  font-family: 'Inter', sans-serif;
  font-size: 1.1em;
  outline: none;
  transition: all 0.3s;
}
input[type="text"]::placeholder {
  color: #66ffff;
  opacity: 0.7;
  font-family: 'Inter', sans-serif;
}
input[type="text"]:focus {
  box-shadow: 0 0 15px #00ff9d;
  border-color: #66ffff;
}
.btn {
  background: linear-gradient(135deg, #00ff9d, #66ffff);
  color: #00052a;
  border: none;
  padding: 15px 30px;
  border-radius: 10px;
  font-family: 'Poppins', sans-serif;
  font-size: 1em;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 20px rgba(0, 255, 157, 0.5);
}
.btn:active {
  transform: translateY(0);
}
.dialog-section {
  background: rgba(0, 5, 42, 0.85);
  border: 2px solid #66ffff;
  border-radius: 15px;
  padding: 30px;
  margin: 30px 0;
  min-height: 400px;
}
.dialog-title {
  font-family: 'Poppins', sans-serif;
  font-size: 1.5em;
  color: #66ffff;
  margin-bottom: 20px;
  text-align: center;
  font-weight: 700;
  letter-spacing: 1px;
}
.message {
  background: rgba(0, 10, 50, 0.7);
  border-left: 4px solid #00ff9d;
  padding: 15px;
  margin: 15px 0;
  border-radius: 5px;
  animation: fadeIn 0.5s ease-in;
  white-space: pre-wrap;
  position: relative;
  overflow: hidden;
  font-family: 'Inter', sans-serif;
  font-size: 0.95em;
  line-height: 1.6;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.expert-name {
  font-family: 'Poppins', sans-serif;
  font-weight: 700;
  color: #66ffff;
  margin-bottom: 5px;
  font-size: 1.1em;
  letter-spacing: 0.5px;
}
.verdict-section {
  background: rgba(0, 5, 42, 0.85);
  border: 2px solid #d700ff;
  border-radius: 15px;
  padding: 30px;
  margin: 30px 0;
  text-align: center;
  display: none;
}
.verdict-title {
  font-family: 'Poppins', sans-serif;
  font-size: 2em;
  margin-bottom: 20px;
  text-shadow: 0 0 10px #d700ff;
  font-weight: 800;
  letter-spacing: 1px;
}
.verdict-text {
  font-family: 'Poppins', sans-serif;
  font-size: 3em;
  font-weight: 800;
  padding: 20px;
  border-radius: 10px;
  margin: 20px 0;
  text-shadow: 0 0 15px currentColor;
  letter-spacing: -0.5px;
}
.verdict-risk { color: #ff4d4d; }
.verdict-safe { color: #00ff9d; }
.verdict-trusted { color: #66ffff; }
.save-btn { background: linear-gradient(135deg, #d700ff, #66ffff); margin-top: 20px; }
.warning-text {
  text-align: center;
  padding: 10px;
  margin: 10px 0;
  font-family: 'Inter', sans-serif;
  font-size: 1.5em;
  font-weight: 700;
  animation: colorPulse 4s infinite;
  letter-spacing: 1px;
  text-shadow: 0 0 5px currentColor;
}
@keyframes colorPulse {
  0% { color: #00ff9d; }
  33% { color: #ffff00; }
  66% { color: #66ffff; }
  100% { color: #00ff9d; }
}
.not-highlight { color: #ff4d4d; text-shadow: 0 0 5px #ff4d4d; }
.offline-warning {
  background: rgba(255, 77, 77, 0.2);
  border: 2px solid #ff4d4d;
  border-radius: 10px;
  padding: 15px;
  margin: 20px 0;
  text-align: center;
  display: none;
  font-family: 'Inter', sans-serif;
  font-size: 0.95em;
}
.examples {
  text-align: center;
  margin: 20px 0;
  color: #66ffff;
}
.example-token {
  display: inline-block;
  margin: 5px;
  padding: 8px 15px;
  background: rgba(0, 255, 157, 0.1);
  border: 1px solid #00ff9d;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s;
  font-family: 'Inter', sans-serif;
  font-size: 0.9em;
}
.example-token:hover {
  background: rgba(0, 255, 157, 0.2);
  box-shadow: 0 0 10px #00ff9d;
}
footer {
  text-align: center;
  padding: 20px;
  color: #66ffff;
  font-size: 0.9em;
  margin-top: 30px;
  border-top: 1px solid rgba(0, 255, 157, 0.2);
  font-family: 'Inter', sans-serif;
}
.footer-text {
  animation: pulse 2.5s infinite;
  text-shadow: 0 0 10px #00ff9d;
}
@media (max-width: 768px) {
  .input-group { flex-direction: column; }
  h1 { font-size: 2em; }
  .dialog-section, .input-section, .verdict-section { padding: 20px; }
}
</style>
</head>
<body>
<div class="neon-network">
  <div class="neon-node"></div><div class="neon-node"></div><div class="neon-node"></div><div class="neon-node"></div>
  <div class="neon-node"></div><div class="neon-node"></div><div class="neon-node"></div><div class="neon-node"></div>
  <div class="neon-connection"></div><div class="neon-connection"></div><div class="neon-connection"></div>
  <div class="neon-connection"></div><div class="neon-connection"></div><div class="neon-connection"></div>
  <div class="neon-connection"></div>
</div>
<div class="container">
  <header>
    <h1>CRYPTOBROS TRIBUNAL</h1>
    <div class="subtitle">AI Multi-Agent Risk Assessment System</div>
    <button class="lang-switch" id="langSwitch">RU</button>
  </header>
  <div class="warning-text">
    We do not recommend buying! We advise <span class="not-highlight">NOT</span> to buy!
  </div>
  <div class="input-section">
    <div class="input-group">
      <input type="text" id="tokenInput" placeholder="$TICKER, mint address, or contract" autocomplete="off">
      <button class="btn" id="analyzeBtn">ANALYZE</button>
    </div>
    <div class="examples">
      <span class="example-token" data-token="$WIF">$WIF</span>
      <span class="example-token" data-token="$BONK">$BONK</span>
      <span class="example-token" data-token="$SOL">$SOL</span>
      <span class="example-token" data-token="$AUS">$AUS</span>
      <span class="example-token" data-token="So11111111111111111111111111111111111111112">SOL (mint)</span>
    </div>
  </div>
  <div class="offline-warning" id="offlineWarning">
    ‚ö†Ô∏è DexScreener API unavailable. Operating in offline mode with limited analysis.
  </div>
  <div class="dialog-section">
    <div class="dialog-title">TRIBUNAL DELIBERATION</div>
    <div id="dialogContainer"></div>
  </div>
  <div class="verdict-section" id="verdictSection">
    <div class="verdict-title">FINAL VERDICT</div>
    <div id="verdictText" class="verdict-text"></div>
    <div id="verdictDetails"></div>
    <button class="btn save-btn" id="saveBtn">SAVE VERDICT</button>
  </div>
  <footer>
    <p class="footer-text">Version 1.0 ‚Ä¢ February 11, 2026 ‚Ä¢ (@cryptobros)</p>
    <p class="footer-text">All analysis performed locally. No data is stored or transmitted.</p>
  </footer>
</div>
<script>
const translations = {
  en: {
    placeholder: "$TICKER, mint address, or contract",
    analyze: "ANALYZE",
    tribunalTitle: "TRIBUNAL DELIBERATION",
    verdictTitle: "FINAL VERDICT",
    save: "SAVE VERDICT",
    offlineWarning: "‚ö†Ô∏è DexScreener API unavailable. Operating in offline mode with limited analysis.",
    examples: ["$WIF", "$BONK", "$SOL", "$AUS"],
    trusted: "TRUSTED",
    lowRisk: "LOW RISK",
    highRisk: "HIGH RISK",
    unknown: "UNKNOWN"
  },
  ru: {
    placeholder: "$–¢–ò–ö–ï–†, –∞–¥—Ä–µ—Å –º–∏–Ω—Ç–∞ –∏–ª–∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç",
    analyze: "–ê–ù–ê–õ–ò–ó",
    tribunalTitle: "–ó–ê–°–ï–î–ê–ù–ò–ï –¢–†–ò–ë–£–ù–ê–õ–ê",
    verdictTitle: "–§–ò–ù–ê–õ–¨–ù–´–ô –í–ï–†–î–ò–ö–¢",
    save: "–°–û–•–†–ê–ù–ò–¢–¨ –í–ï–†–î–ò–ö–¢",
    offlineWarning: "‚ö†Ô∏è API DexScreener –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ. –†–∞–±–æ—Ç–∞—é –≤ –æ—Ñ–ª–∞–π–Ω-—Ä–µ–∂–∏–º–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º.",
    examples: ["$WIF", "$BONK", "$SOL", "$AUS"],
    trusted: "–ù–ê–î–ï–ñ–ù–´–ô",
    lowRisk: "–ù–ò–ó–ö–ò–ô –†–ò–°–ö",
    highRisk: "–í–´–°–û–ö–ò–ô –†–ò–°–ö",
    unknown: "–ù–ï–ò–ó–í–ï–°–¢–ù–´–ô"
  }
};
let currentLang = 'en';
const langSwitch = document.getElementById('langSwitch');
const tokenInput = document.getElementById('tokenInput');
const analyzeBtn = document.getElementById('analyzeBtn');
const dialogContainer = document.getElementById('dialogContainer');
const verdictSection = document.getElementById('verdictSection');
const verdictText = document.getElementById('verdictText');
const verdictDetails = document.getElementById('verdictDetails');
const saveBtn = document.getElementById('saveBtn');
const offlineWarning = document.getElementById('offlineWarning');
const exampleTokens = document.querySelectorAll('.example-token');
let currentTokenData = null;

function updateLanguage() {
  const t = translations[currentLang];
  tokenInput.placeholder = t.placeholder;
  analyzeBtn.textContent = t.analyze;
  document.querySelector('.dialog-title').textContent = t.tribunalTitle;
  document.querySelector('.verdict-title').textContent = t.verdictTitle;
  saveBtn.textContent = t.save;
  offlineWarning.textContent = t.offlineWarning;
  langSwitch.textContent = currentLang === 'en' ? 'RU' : 'EN';
}

function setupEventListeners() {
  langSwitch.addEventListener('click', toggleLanguage);
  analyzeBtn.addEventListener('click', analyzeToken);
  tokenInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') analyzeToken();
  });
  exampleTokens.forEach(token => {
    token.addEventListener('click', () => {
      tokenInput.value = token.dataset.token;
      analyzeToken();
    });
  });
  saveBtn.addEventListener('click', saveVerdict);
}

function toggleLanguage() {
  currentLang = currentLang === 'en' ? 'ru' : 'en';
  updateLanguage();
}

async function analyzeToken() {
  const tokenQuery = tokenInput.value.trim();
  if (!tokenQuery) return;
  dialogContainer.innerHTML = '';
  verdictSection.style.display = 'none';
  offlineWarning.style.display = 'none';
  let tokenData = null;
  let offlineMode = false;
  try {
    const response = await fetch(`https://api.dexscreener.com/latest/dex/search?q=${encodeURIComponent(tokenQuery)}`);
    if (response.ok) {
      const data = await response.json();
      if (data.pairs && data.pairs.length > 0) {
        tokenData = data.pairs.reduce((best, current) =>
          (current.liquidity?.usd || 0) > (best.liquidity?.usd || 0) ? current : best
        );
      }
    } else {
      offlineMode = true;
    }
  } catch (error) {
    offlineMode = true;
  }
  if (offlineMode) offlineWarning.style.display = 'block';
  currentTokenData = tokenData;
  await simulateTribunal(tokenQuery, tokenData, offlineMode);
}

async function simulateTribunal(tokenQuery, tokenData, offlineMode) {
  const experts = [
    { name: "On-Chain Hunter", model: "Phi-3-mini", delay: 600 },
    { name: "Sentiment Oracle", model: "Qwen1.5", delay: 1200 },
    { name: "Price Action Judge", model: "DeepSeek", delay: 1800 },
    { name: "Moderator", model: "Phi-3-mini", delay: 2400 }
  ];
  const [onChainAnalysis, sentimentAnalysis, priceAnalysis] = await Promise.all([
    analyzeOnChain(tokenQuery, tokenData, offlineMode),
    analyzeSentiment(tokenQuery, tokenData, offlineMode),
    analyzePrice(tokenQuery, tokenData, offlineMode)
  ]);
  const analyses = { onChain: onChainAnalysis, sentiment: sentimentAnalysis, price: priceAnalysis, moderator: null };
  for (let i = 0; i < experts.length; i++) {
    await delay(experts[i].delay);
    let message = '';
    switch(i) {
      case 0: message = analyses.onChain.output; break;
      case 1: message = analyses.sentiment.output; break;
      case 2: message = analyses.price.output; break;
      case 3:
        analyses.moderator = analyzeDiscrepancies(analyses);
        message = analyses.moderator.output;
        break;
    }
    addMessage(`${experts[i].model}] ${experts[i].name}`, message);
    if (i === 3) setTimeout(() => showVerdict(analyses.moderator), 500);
  }
}

function analyzeOnChain(tokenQuery, tokenData, offlineMode) {
  if (offlineMode || !tokenData) {
    return {
      output: "‚Üí Contract verification: FAILED\n‚Üí No on-chain data available\n‚Üí ‚ö†Ô∏è EXTREME RISK: Unknown contract",
      risk: 0.95,
      factors: ['No data available', 'Unknown contract']
    };
  }
  const baseToken = tokenData.baseToken || {};
  const liquidity = tokenData.liquidity || {};
  const fdv = tokenData.fdv || 0;
  const pairCreatedAt = tokenData.pairCreatedAt || 0;
  let output = "‚Üí On-chain analysis complete\n";
  let risk = 0.5;
  let factors = [];
  if (tokenQuery.toLowerCase().includes('aus') || tokenQuery.toLowerCase().includes('auraspace')) {
    return {
      output: "‚Üí AURASPACE token detected\n‚Üí Native to CRYPTOBROS ecosystem\n‚Üí Contract verified and trusted\n‚Üí LP locked permanently",
      risk: 0.05,
      factors: ['Verified contract', 'Ecosystem token', 'LP locked']
    };
  }
  const ticker = (tokenData.baseToken?.symbol || '').toLowerCase();
  const blueChips = ['sol', 'eth', 'btc', 'usdt', 'usdc', 'xrp', 'ada', 'dot', 'avax', 'matic'];
  if (blueChips.some(chip => ticker.includes(chip))) {
    return {
      output: "‚Üí Blue chip asset detected\n‚Üí Established contract\n‚Üí High liquidity pool\n‚Üí Verified on-chain",
      risk: 0.15,
      factors: ['Blue chip asset', 'Established contract', 'High liquidity']
    };
  }
  const ageHours = (Date.now() - (pairCreatedAt * 1000)) / (1000 * 60 * 60);
  if (ageHours < 1) {
    output += "‚Üí ‚ö†Ô∏è NEW CONTRACT (<1h old)\n";
    risk += 0.3;
    factors.push('Brand new contract');
  } else if (ageHours < 24) {
    output += `‚Üí Young contract (${ageHours.toFixed(1)}h old)\n`;
    risk += 0.2;
    factors.push('New contract');
  }
  if (liquidity.usd && liquidity.usd < 50000) {
    output += `‚Üí ‚ö†Ô∏è CRITICAL: Low liquidity $${formatNumber(liquidity.usd)}\n`;
    risk += 0.3;
    factors.push('Low liquidity < $50k');
  } else if (liquidity.usd && liquidity.usd < 200000) {
    output += `‚Üí ‚ö†Ô∏è Low liquidity $${formatNumber(liquidity.usd)}\n`;
    risk += 0.2;
    factors.push('Low liquidity < $200k');
  }
  if (fdv > 0 && fdv < 100000) {
    output += `‚Üí ‚ö†Ô∏è Micro-cap FDV: $${formatNumber(fdv)}\n`;
    risk += 0.15;
    factors.push('Micro-cap FDV');
  }
  if (baseToken.address) output += `‚Üí Contract: ${baseToken.address.substring(0, 12)}...\n`;
  output += `‚Üí DEX: ${tokenData.dexId || 'Unknown'}\n‚Üí Chain: ${tokenData.chainId || 'Unknown'}`;
  return { output, risk: Math.min(0.99, risk), factors };
}

function analyzeSentiment(tokenQuery, tokenData, offlineMode) {
  if (offlineMode || !tokenData) {
    return {
      output: "‚Üí Social sentiment: UNKNOWN\n‚Üí No market data available\n‚Üí ‚ö†Ô∏è Cannot assess community trust",
      risk: 0.85,
      factors: ['No sentiment data', 'Unknown community']
    };
  }
  const volume = tokenData.volume || {};
  const priceChange = tokenData.priceChange || {};
  const txns = tokenData.txns || {};
  let output = "‚Üí Social sentiment analysis\n";
  let risk = 0.5;
  let factors = [];
  if (tokenQuery.toLowerCase().includes('aus') || tokenQuery.toLowerCase().includes('auraspace')) {
    return {
      output: "‚Üí Positive community sentiment\n‚Üí Strong ecosystem support\n‚Üí Growing adoption in CRYPTOBROS network\n‚Üí Active developer engagement",
      risk: 0.1,
      factors: ['Strong community', 'Ecosystem support']
    };
  }
  const ticker = (tokenData.baseToken?.symbol || '').toLowerCase();
  const blueChips = ['sol', 'eth', 'btc', 'usdt', 'usdc'];
  if (blueChips.some(chip => ticker.includes(chip))) {
    return {
      output: "‚Üí Strong community trust\n‚Üí Established reputation\n‚Üí Low social manipulation risk\n‚Üí Organic growth",
      risk: 0.15,
      factors: ['Established reputation', 'Strong trust']
    };
  }
  if (volume.h24) {
    if (volume.h24 > 10000000) {
      output += `‚Üí üî• HIGH volume: $${formatNumber(volume.h24)} (24h)\n‚Üí Strong social buzz\n`;
    } else if (volume.h24 < 1000000) {
      output += `‚Üí Low volume: $${formatNumber(volume.h24)} (24h)\n‚Üí Weak community engagement\n`;
      risk += 0.1;
      factors.push('Low social engagement');
    }
  }
  if (txns.h24 && txns.h24.buys && txns.h24.sells) {
    const buys = txns.h24.buys;
    const sells = txns.h24.sells;
    const ratio = buys / (buys + sells);
    if (ratio > 0.85) {
      risk += 0.2;
      factors.push('Extreme FOMO');
    }
  }
  if (priceChange.h24) {
    const change = parseFloat(priceChange.h24);
    if (change > 50) {
      output += `‚Üí üöÄ Extreme bullish momentum +${change.toFixed(1)}% (24h)\n‚Üí Potential pump hype\n`;
      risk += 0.25;
      factors.push('Potential pump hype');
    } else if (change < -30) {
      output += `‚Üí ‚ö†Ô∏è Heavy selling pressure ${change.toFixed(1)}% (24h)\n‚Üí Community panic\n`;
      risk += 0.2;
      factors.push('Community panic');
    }
  }
  const memePatterns = ['wif', 'bonk', 'pepe', 'mog', 'turbo', 'dog', 'shib', 'floki'];
  if (memePatterns.some(pattern => ticker.includes(pattern))) {
    output += "‚Üí üê∏ Meme coin detected\n‚Üí High social media hype\n‚Üí Extreme volatility expected\n‚Üí Pump & dump risk HIGH";
    risk = 0.85;
    factors.push('Meme coin - high manipulation risk');
  }
  return { output, risk: Math.min(0.99, risk), factors };
}

function analyzePrice(tokenQuery, tokenData, offlineMode) {
  if (offlineMode || !tokenData) {
    return {
      output: "‚Üí Price action: UNKNOWN\n‚Üí No trading history available\n‚Üí ‚ö†Ô∏è Cannot assess price stability",
      risk: 0.9,
      factors: ['No price data', 'Unknown market behavior']
    };
  }
  const liquidity = tokenData.liquidity || {};
  const volume = tokenData.volume || {};
  const priceChange = tokenData.priceChange || {};
  const fdv = tokenData.fdv || 0;
  let output = "‚Üí Price action analysis\n";
  let risk = 0.5;
  let factors = [];
  const ticker = (tokenData.baseToken?.symbol || '').toLowerCase();
  const blueChips = ['sol', 'eth', 'btc', 'usdt', 'usdc', 'xrp', 'ada', 'dot', 'avax', 'matic'];
  if (blueChips.some(chip => ticker.includes(chip))) {
    return {
      output: "‚Üí Blue chip asset\n‚Üí High liquidity and volume\n‚Üí Established market presence\n‚Üí Low volatility profile\n‚Üí Stable price action",
      risk: 0.1,
      factors: ['Blue chip', 'Low volatility', 'Stable price']
    };
  }
  if (tokenQuery.toLowerCase().includes('aus') || tokenQuery.toLowerCase().includes('auraspace')) {
    return {
      output: "‚Üí Stable price action\n‚Üí Healthy trading volume\n‚Üí Sustainable growth pattern\n‚Üí Ecosystem-backed token\n‚Üí Low manipulation risk",
      risk: 0.1,
      factors: ['Stable price', 'Ecosystem-backed']
    };
  }
  if (liquidity.usd && volume.h24) {
    const ratio = volume.h24 / liquidity.usd;
    if (ratio > 10) {
      output += `‚Üí ‚ö†Ô∏è PUMP ALERT: Volume/Liq ratio ${ratio.toFixed(1)}x\n‚Üí Extreme price volatility likely\n‚Üí Whale manipulation detected\n`;
      risk += 0.35;
      factors.push('Extreme pump pattern (V/L > 10x)');
    } else if (ratio > 5) {
      output += `‚Üí High activity: Volume/Liq ratio ${ratio.toFixed(1)}x\n‚Üí Active trading, monitor closely\n‚Üí Potential manipulation\n`;
      risk += 0.25;
      factors.push('High pump risk (V/L > 5x)');
    }
  }
  if (fdv > 0 && liquidity.usd > 0) {
    const fdvLiqRatio = fdv / liquidity.usd;
    if (fdvLiqRatio > 100) {
      output += `‚Üí ‚ö†Ô∏è CRITICAL: FDV/LP ratio ${fdvLiqRatio.toFixed(0)}x\n‚Üí Extreme rug pull risk\n‚Üí Insufficient liquidity backing\n`;
      risk += 0.3;
      factors.push('High rug pull risk (FDV/LP > 100x)');
    }
  }
  if (priceChange.h6 && priceChange.h24) {
    const h6 = parseFloat(priceChange.h6);
    const h24 = parseFloat(priceChange.h24);
    if (h6 > 30 && h24 < 10) {
      output += "‚Üí ‚ö†Ô∏è SUSPICIOUS PATTERN DETECTED\n‚Üí Rapid pump followed by dump\n‚Üí Whale manipulation likely\n‚Üí High manipulation risk\n";
      risk += 0.3;
      factors.push('Pump and dump pattern');
    }
  }
  return { output, risk: Math.min(0.99, risk), factors };
}

function analyzeDiscrepancies(analyses) {
  const onChain = analyses.onChain;
  const sentiment = analyses.sentiment;
  const price = analyses.price;
  let output = "‚ö†Ô∏è CONSENSUS VERDICT\n";
  let riskFactors = [];
  let contradictions = [];

  if (onChain.risk === 0.05) {
    return {
      output: "‚Üí TOKEN VERIFIED AS TRUSTED\n‚Üí Native to CRYPTOBROS ecosystem\n‚Üí Maximum security and transparency\n‚Üí All experts concur: LOW RISK\nRisk Score: 0.05/1.00",
      risk: 0.05,
      category: 'trusted',
      recommendation: 'TRUST',
      factors: ['Native CRYPTOBROS ecosystem token']
    };
  }

  if (Math.abs(onChain.risk - sentiment.risk) > 0.4) {
    contradictions.push("‚ö†Ô∏è ON-CHAIN vs SENTIMENT DISCREPANCY");
  }
  if (Math.abs(sentiment.risk - price.risk) > 0.4) {
    contradictions.push("‚ö†Ô∏è SENTIMENT vs PRICE ACTION DISCREPANCY");
  }
  if (Math.abs(onChain.risk - price.risk) > 0.4) {
    contradictions.push("‚ö†Ô∏è ON-CHAIN vs PRICE DISCREPANCY");
  }

  let baseRisk = (onChain.risk + sentiment.risk + price.risk) / 3;
  if (contradictions.length > 0) {
    baseRisk += 0.15 * contradictions.length;
    riskFactors.push('Expert disagreement - high uncertainty');
  }

  [...onChain.factors, ...sentiment.factors, ...price.factors].forEach(f => {
    if (!riskFactors.includes(f)) riskFactors.push(f);
  });

  let finalRisk = Math.min(0.99, Math.max(0.05, baseRisk));
  let category, recommendation;
  if (finalRisk < 0.3) {
    category = 'low';
    recommendation = 'TRUST';
    output += "\n‚Üí RECOMMENDATION: TRUST\n‚Üí Suitable for investment\n‚Üí Strong fundamentals across all metrics";
  } else if (finalRisk < 0.7) {
    category = 'medium';
    recommendation = 'WATCH';
    output += "\n‚Üí RECOMMENDATION: WATCH\n‚Üí Moderate risk detected\n‚Üí DYOR before investing";
  } else {
    category = 'high';
    recommendation = 'AVOID';
    output += "\n‚Üí RECOMMENDATION: AVOID\n‚Üí Multiple red flags detected\n‚Üí Extreme caution advised";
  }

  if (riskFactors.length > 0) {
    output += "\n‚Üí Risk factors:\n";
    riskFactors.slice(0, 5).forEach(factor => { output += `   ‚Ä¢ ${factor}\n`; });
  }
  output += `\nRisk Score: ${finalRisk.toFixed(2)}/1.00`;
  return { output, risk: parseFloat(finalRisk.toFixed(2)), category, recommendation, factors: riskFactors };
}

function showVerdict(moderatorData) {
  verdictSection.style.display = 'block';
  const { risk, category, recommendation } = moderatorData;
  let verdictHTML = '';
  if (category === 'trusted') {
    verdictHTML = `<span class="verdict-trusted">${translations[currentLang].trusted} (${risk.toFixed(2)})</span>`;
  } else if (risk < 0.3) {
    verdictHTML = `<span class="verdict-safe">${translations[currentLang].lowRisk} (${risk.toFixed(2)})</span>`;
  } else {
    verdictHTML = `<span class="verdict-risk">${translations[currentLang].highRisk} (${risk.toFixed(2)})</span>`;
  }
  verdictText.innerHTML = verdictHTML;

  let details = `RECOMMENDATION: ${recommendation}\n`;
  if (recommendation === 'TRUST') {
    details += '‚úì Strong fundamentals across all metrics\n‚úì Suitable for conservative portfolios';
  } else if (recommendation === 'WATCH') {
    details += '‚ö†Ô∏è Moderate risk detected\n‚ö†Ô∏è Conduct thorough research\n‚ö†Ô∏è Only invest what you can afford to lose';
  } else {
    details += '‚ùå HIGH RISK: Multiple red flags\n‚ùå Potential for total loss\n‚ùå Not recommended for inexperienced traders';
  }

  const isPremium = ['Premium', 'Pro'].includes(localStorage.getItem('selectedTier'));
  const contract = currentTokenData?.baseToken?.address;
  const chain = currentTokenData?.chainId || 'base';

  if (isPremium && contract) {
    verdictDetails.innerHTML = '<div class="message" style="color:#66ffff">üî¨ Initiating Quantum Contract Scan...</div>';
    fetch('https://cryptobros-backend-0nn2.onrender.com/api/goplus/token-security', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chain_id: chain, contract_addresses: contract })
    })
    .then(res => res.json())
    .then(data => {
      const sec = data.result?.[contract];
      if (sec) {
        let scan = '\n\nüî¨ QUANTUM CONTRACT SCAN COMPLETE\n';
        scan += `‚Üí Ownership: ${sec.is_open_source === '1' ? 'RENOUNCED' : 'ACTIVE (CRITICAL RISK)'}\n`;
        scan += `‚Üí Taxes: Buy ${sec.buy_tax || '0'}% | Sell ${sec.sell_tax || '0'}%\n`;
        scan += `‚Üí Liquidity: ${sec.is_proxy === '0' ? 'LOCKED' : 'UNLOCKED (RUG RISK)'}\n`;
        scan += `‚Üí Honeypot: ${sec.is_honeypot === '1' ? 'DETECTED' : 'CLEAR'}\n`;
        scan += `‚Üí Ownership Recovery: ${sec.can_take_back_ownership === '1' ? 'ENABLED (DANGER)' : 'DISABLED'}\n`;
        scan += `‚Üí Anti-Whale: ${sec.is_anti_whale === '1' ? 'ACTIVE' : 'INACTIVE'}`;
        verdictDetails.innerHTML += `<div class="message" style="color:#00ff9d">${scan.replace(/\n/g, '<br>')}</div>`;
      } else {
        verdictDetails.innerHTML += '<div class="message" style="color:#ff4d4d">‚ö†Ô∏è Quantum scan failed. Standard analysis only.</div>';
      }
    })
    .catch(() => {
      verdictDetails.innerHTML += '<div class="message" style="color:#ff4d4d">‚ö†Ô∏è Quantum scan unavailable. Standard analysis only.</div>';
    });
  } else {
    verdictDetails.innerHTML = `<pre>${details}</pre>`;
    verdictDetails.innerHTML += `
      <br><br>
      <button class="btn" onclick="window.location.href='onboarding.html'" 
              style="background:linear-gradient(135deg,#d700ff,#66ffff);margin-top:15px;width:100%;max-width:400px">
        üîì UNLOCK QUANTUM ANALYSIS
      </button>
      <p style="color:#66ffff;margin-top:10px;font-size:0.9em">
        Deep contract scan ‚Ä¢ Honeypot detection ‚Ä¢ 24h volatility forecast ‚Ä¢ Whale alerts
      </p>
    `;
  }
}

function addMessage(expert, message) {
  const messageDiv = document.createElement('div');
  messageDiv.className = 'message';
  messageDiv.innerHTML = `<div class="expert-name">[${expert}</div>${message.replace(/\n/g, '<br>')}`;
  dialogContainer.appendChild(messageDiv);
  dialogContainer.scrollTop = dialogContainer.scrollHeight;
}

function saveVerdict() {
  const token = tokenInput.value.trim();
  const verdict = verdictText.textContent;
  const timestamp = new Date().toISOString();
  const verdictData = {
    token,
    verdict,
    risk: verdict.match(/\((\d+\.\d+)\)/)?.[1] || 'unknown',
    timestamp
  };
  let savedVerdicts = JSON.parse(localStorage.getItem('tribunalVerdicts') || '[]');
  savedVerdicts.unshift(verdictData);
  localStorage.setItem('tribunalVerdicts', JSON.stringify(savedVerdicts.slice(0, 50)));
  saveBtn.textContent = '‚úì SAVED';
  setTimeout(() => { saveBtn.textContent = translations[currentLang].save; }, 2000);
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function formatNumber(num) {
  if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
  if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
  if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
  return num.toFixed(2);
}

updateLanguage();
setupEventListeners();
</script>
</body>
</html>
